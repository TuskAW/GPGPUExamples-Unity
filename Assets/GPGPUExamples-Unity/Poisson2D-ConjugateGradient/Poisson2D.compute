#pragma kernel CsCopyVector
#pragma kernel CsLpMV
#pragma kernel CsSzaxpy
#pragma kernel CsDotProduct

#define THREADS_X 16
#define THREADS_Y 16

RWTexture2D<float> _b;
RWTexture2D<float> _vk;
RWTexture2D<float> _Lv;

RWTexture2D<float> _x;
RWTexture2D<float> _y;
RWTexture2D<float> _z;

RWTexture2D<float> _VectorA;
RWTexture2D<float> _VectorB;
RWStructuredBuffer<float> _PartialDot;
groupshared float groupsum[THREADS_X*THREADS_Y];

cbuffer params
{
    int _width;
    int _height;
    int _numOfGroupsX;
    int _h;
    float _alpha;
};

[numthreads(THREADS_X, THREADS_Y, 1)]
void CsCopyVector(uint2 i : SV_DispatchThreadID)
{
    _y[i] = _x[i];
}

//============================================
// Laplacian matrix and vector multiplication
//============================================
[numthreads(THREADS_X, THREADS_Y, 1)]
void CsLpMV(uint2 i : SV_DispatchThreadID)
{
    bool isBoundary = (i.x <= 0) || (i.x >= _width-1) || (i.y <= 0) || (i.y >= _height-1);
    if (!isBoundary)
    {
        uint2 xp1 = uint2(i.x + 1, i.y);
        uint2 xm1 = uint2(i.x - 1, i.y);
        uint2 yp1 = uint2(i.x, i.y + 1);
        uint2 ym1 = uint2(i.x, i.y - 1);

        // Finite Difference for 2D
        _Lv[i] = (_vk[xm1] + _vk[ym1] - 4.0*_vk[i] + _vk[xp1] + _vk[yp1])/(_h*_h);
    }
}

//============================================
// z = a*x + y
//============================================
[numthreads(THREADS_X, THREADS_Y, 1)]
void CsSzaxpy(uint2 i : SV_DispatchThreadID)
{
    _z[i] = _alpha * _x[i] + _y[i];
}

[numthreads(THREADS_X, THREADS_Y, 1)]
void CsDotProduct(uint2 id : SV_DispatchThreadID, uint2 gtid : SV_GroupThreadID, uint2 gid : SV_GroupID)
{
    // Each thread loads one element from global to shared mem
    groupsum[gtid.x + THREADS_X*gtid.y] = _VectorA[id]*_VectorB[id];
    GroupMemoryBarrierWithGroupSync();

    // Do reduction in shared mem
    for(unsigned int s=(THREADS_X*THREADS_Y)/2; s>0; s>>=1)
    {
        uint index = gtid.x + THREADS_X*gtid.y;
        if (index < s)
        {
            groupsum[index] += groupsum[index + s];
        }
        GroupMemoryBarrierWithGroupSync();
    }

    // Write result for this block to global mem
    if (gtid.x == 0 && gtid.y == 0)
    {
        _PartialDot[gid.x + _numOfGroupsX*gid.y] = groupsum[0];
    }
}
